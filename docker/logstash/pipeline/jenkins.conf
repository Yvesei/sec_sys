input {
  beats {
    port => 5044
  }
  
  # Generate synthetic logs for demonstration
  generator {
    message => '127.0.0.1 - admin [12/Feb/2026:10:30:45 +0000] "GET /api/json HTTP/1.1" 200 5234 "-" "Mozilla/5.0"'
    count => 0
  }
}

filter {
  # Parse Jenkins Access Logs (Enhanced Common Log Format)
  if [log_type] == "jenkins_access" {
    grok {
      match => {
        "message" => '%{IPORHOST:client_ip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "%{WORD:http_method} %{URIPATHPARAM:request_path} HTTP/%{NUMBER:http_version}" %{NUMBER:response_code} (?:%{NUMBER:bytes}|-) "%{DATA:referrer}" "%{DATA:user_agent}"'
      }
    }
    
    date {
      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      target => "@timestamp"
    }
    
    mutate {
      convert => {
        "response_code" => "integer"
        "bytes" => "integer"
      }
      add_field => {
        "http_method" => "%{[http_method]}"
        "request_path" => "%{[request_path]}"
        "response_code" => "%{[response_code]}"
        "bytes" => "%{[bytes]}"
        "user_agent" => "%{[user_agent]}"
        "referrer" => "%{[referrer]}"
      }
    }
    
    # Extract query parameters
    if "?" in [request_path] {
      mutate {
        split => { "request_path" => "?" }
      }

      kv {
        source => "[request_path][1]"
        field_split => "&"
        value_split => "="
        target => "query_params"
      }
    }
    
    # Tag error responses
    if [response_code] >= 400 {
      mutate {
        add_tag => [ "http_error" ]
      }
    }
    
    if [response_code] == 401 or [response_code] == 403 {
      mutate {
        add_tag => [ "authentication_failure" ]
      }
    }
    
    # Detect path traversal attempts
    if [request_path] =~ /\.\./ {
      mutate {
        add_tag => [ "path_traversal_attempt" ]
      }
    }
    
    # Detect script console access
    if [request_path] =~ /\/script/ {
      mutate {
        add_tag => [ "script_console_access" ]
      }
    }
    
    # Detect API enumeration
    if [request_path] =~ /\/api\// {
      mutate {
        add_tag => [ "api_access" ]
      }
    }
    
    # Detect sensitive endpoints
    if [request_path] =~ /\/configure/ or [request_path] =~ /\/system/ {
      mutate {
        add_tag => [ "sensitive_endpoint" ]
      }
    }
    
    # Detect job creation/deletion
    if [request_path] =~ /\/createItem/ or [request_path] =~ /\/doDelete/ {
      mutate {
        add_tag => [ "job_management" ]
      }
    }
    
    # GeoIP lookup
    geoip {
      source => "client_ip"
      target => "geoip"
    }
    
    # User agent parsing
    useragent {
      source => "user_agent"
      target => "user_agent_info"
    }
  }
  
  # Parse Jenkins Application Logs
  if [log_type] == "jenkins_application" {
    grok {
      match => {
        "message" => '%{TIMESTAMP_ISO8601:timestamp} \[%{DATA:thread}\] %{LOGLEVEL:log_level}%{SPACE}%{JAVACLASS:java_class} - %{GREEDYDATA:log_message}'
      }
    }
    
    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
      target => "@timestamp"
    }
    
    # Extract meaningful information from application logs
    if [log_message] =~ /(Starting|Completed|Failed|Success|Error|Warning|Exception)/ {
      mutate {
        add_tag => [ "important_event" ]
      }
    }
    
    # Detect authentication events
    if [log_message] =~ /(login|authentication|security|session)/i {
      mutate {
        add_tag => [ "authentication_event" ]
      }
    }
    
    # Detect plugin events
    if [log_message] =~ /(plugin|extension|dependency)/i {
      mutate {
        add_tag => [ "plugin_event" ]
      }
    }
  }
  
  # Parse Jenkins Build Logs
  if [log_type] == "jenkins_build" {
    grok {
      match => {
        "message" => '%{TIMESTAMP_ISO8601:timestamp} %{GREEDYDATA:build_log}'
      }
    }
    
    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss" ]
      target => "@timestamp"
    }
    
    # Extract build information
    if [build_log] =~ /(Building|Compiling|Running|Testing|Deploying|Success|Failure|Error)/ {
      mutate {
        add_tag => [ "build_event" ]
      }
    }
    
    # Detect build failures
    if [build_log] =~ /(BUILD FAILED|FAILURE|ERROR)/ {
      mutate {
        add_tag => [ "build_failure" ]
      }
    }
    
    # Detect build successes
    if [build_log] =~ /(BUILD SUCCESS|SUCCESS|Completed successfully)/ {
      mutate {
        add_tag => [ "build_success" ]
      }
    }
  }
  
  # Parse Loki Container Logs
  if [log_type] == "loki_container" {
    json {
      source => "message"
      target => "docker"
    }
    
    date {
      match => [ "docker.time", "ISO8601" ]
      target => "@timestamp"
    }
    
    mutate {
      add_field => {
        "container_name" => "%{[docker.container_name]}"
        "container_id" => "%{[docker.container_id]}"
        "log_source" => "%{[docker.source]}"
      }
    }
    
    # Extract Jenkins-specific container logs
    if [docker.container_name] =~ /jenkins/ {
      mutate {
        add_tag => [ "jenkins_container" ]
      }
      
      # Parse Jenkins console output
      if [docker.log] =~ /(Starting|Running|Completed|Failed|Error|Warning)/ {
        mutate {
          add_tag => [ "jenkins_console_event" ]
        }
      }
    }
    
    # Extract Filebeat container logs
    if [docker.container_name] =~ /filebeat/ {
      mutate {
        add_tag => [ "filebeat_container" ]
      }
    }
    
    # Extract Logstash container logs
    if [docker.container_name] =~ /logstash/ {
      mutate {
        add_tag => [ "logstash_container" ]
      }
    }
  }
  
  # Parse HTTP Logs
  if [log_type] == "jenkins_http" {
    grok {
      match => {
        "message" => '%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{JAVACLASS:java_class} - %{GREEDYDATA:http_log}'
      }
    }
    
    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
      target => "@timestamp"
    }
    
    # Extract HTTP request details
    if [http_log] =~ /(GET|POST|PUT|DELETE|HEAD) \/.* HTTP\/\d\.\d/ {
      grok {
        match => {
          "http_log" => '%{WORD:http_method} %{URIPATHPARAM:request_path} HTTP/%{NUMBER:http_version}'
        }
      }
      mutate {
        add_tag => [ "http_request" ]
      }
    }
  }
  
  # Parse Plugin Logs
  if [log_type] == "jenkins_plugin" {
    grok {
      match => {
        "message" => '%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{JAVACLASS:java_class} - %{GREEDYDATA:plugin_log}'
      }
    }
    
    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
      target => "@timestamp"
    }
    
    # Detect plugin events
    if [plugin_log] =~ /(Loading|Loaded|Installing|Installed|Updating|Updated|Failed)/ {
      mutate {
        add_tag => [ "plugin_event" ]
      }
    }
    
    # Detect plugin errors
    if [plugin_log] =~ /(ERROR|Exception|Failed)/ {
      mutate {
        add_tag => [ "plugin_error" ]
      }
    }
  }
  
  # Parse Jenkins Audit Logs (JSON)
  if [log_type] == "jenkins_audit" {
    json {
      source => "message"
    }
    
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }
  
  # Remove temporary fields
  mutate {
    remove_field => [ "message", "ident", "timestamp" ]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "jenkins-logs-%{+YYYY.MM.dd}"
    document_type => "_doc"
  }
  
  # Debug output - log all processed events to stdout
  stdout {
    codec => rubydebug
  }
}
